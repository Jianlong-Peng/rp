'''
#=============================================================================
#     FileName: evaluate_smartcyp.py
#         Desc: 
#       Author: jlpeng
#        Email: jlpeng1201@gmail.com
#     HomePage: 
#      Version: 0.0.1
#      Created: 2015-03-09 20:38:49
#   LastChange: 2015-03-10 17:02:09
#      History:
#=============================================================================
'''
import sys

def main(argv=sys.argv):
    if len(argv) != 6:
        print "\n  Usage: %s [--train|--test] k des_file som_file predict.csv"%argv[0]
        print "  [--train|--test]:"
        print "      actually, `--train` for training set, which has no `35`"
        print "  k          : report top-1 to top-k results"
        print "  des_file   : descriptor, same as input for gap_predict"
        print "  som_file   : file of actual SOMs"
        print "  predict.csv: file generated by smartcyp"
        print "\nAttention"
        print "  1. reports are based on SOMs with only one atom"
        print "     - considering all types of SOMs"
        print "     - exclude SOM type `6`(O-conjugation)"
        print ""
        sys.exit(1)

    if argv[1] == "--train":
        _type = "train"
    elif argv[1] == "--test":
        _type = "test"
    else:
        print "Error: invalid option",argv[1]
        sys.exit(1)

    k = int(argv[2])

    des = load_des(argv[3])   #key=name, value=[(atom,type),...]

    actual_all,actual_no6  = load_som(argv[4], des)      #key=name, value=[site1,site2,...]
    predict = load_predict(argv[5],_type,des)  #key=name, value=[(atom,rank,score),...]

    print "===report considering all SOMs except those with more than one atoms==="
    do_evaluate(actual_all,predict,k)
    print "\n===report exclude SOM type 6 (O-conjugation) and more than one atoms==="
    do_evaluate(actual_no6,predict,k)


def do_evaluate(actual,predict,k):
    results = []
    for i in xrange(1,k+1):
        total,miss,right = evaluate(actual,predict,i)
        error = total-miss-right
        results.append((i,right,error))
    print "totally %d samples, of which %d has no SOM labeled"%(total,miss)
    print "k  total miss right error accuracy"
    for k,right,error in results:
        print "%-2d %-5d %-5d %-g"%(k,right,error,1.*right/(right+error))
    print ""


def load_des(infile):
    des = {}
    inf = open(infile,'r')
    line = inf.readline()
    while line != "":
        name = line.split()[0].split("\\")[-1]
        name = name[:name.rfind(".")]
        des[name] = []
        line = inf.readline()
        while line!="" and line.startswith("\t"):
            temp = line.strip().split(",")[0]
            atom,type,val = temp.split(":")
            des[name].append((atom,type))
            line = inf.readline()
    inf.close()
    return des

def valid(actual,atom):
    for a,t in actual:
        if a==atom and t=='6':
            return False
    return True

def load_som(infile, des):
    actual_all = {}
    actual_no6 = {}
    inf = open(infile,'r')
    line = inf.readline()
    for line in inf:
        line = line.strip().split("\t")
        if not des.has_key(line[0]):
            continue
        actual_all[line[0]] = []
        actual_no6[line[0]] = []
        for atom in line[3:]:
            if "-" in atom:
                continue
            actual_all[line[0]].append(atom)
            if valid(des[line[0]],atom):
                actual_no6[line[0]].append(atom)
    inf.close()

    return actual_all,actual_no6


def load_predict(infile,_type,des):
    predict = {}
    inf = open(infile,'r')
    line = inf.readline()
    for line in inf:
        line = line.strip().split(",")
        if _type=="train" and int(line[0])>=35:
            name = str(int(line[0])+1)
        else:
            name = line[0]
        if not des.has_key(name):
            continue
        if not predict.has_key(name):
            predict[name] = []
        #(atom,rank,score)
        predict[name].append((line[1].split(".")[-1],int(line[2]),line[3]))
    inf.close()

    for key,value in predict.iteritems():
        value.sort(key=lambda x:x[1])

    return predict

def evaluate(actual,predict,k):
    total = 0
    miss = 0
    right = 0

    for name in actual.iterkeys():
        total += 1
        if len(actual[name]) == 0:
            miss += 1
            continue
        found = False
        for item in predict[name][:k]:
            if item[0] in actual[name]:
                found = True
                break
        if found:
            right += 1

    return total,miss,right

main()


