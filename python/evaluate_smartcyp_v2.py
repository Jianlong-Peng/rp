'''
#=============================================================================
#     FileName: evaluate_smartcyp_v2.py
#         Desc: 
#       Author: jlpeng
#        Email: jlpeng1201@gmail.com
#     HomePage: 
#      Version: 0.0.1
#      Created: 2015-03-09 20:38:49
#   LastChange: 2015-03-10 17:58:21
#      History:
#=============================================================================
'''
import sys

mol_names = []

def main(argv=sys.argv):
    if len(argv) != 6:
        print "\n  Usage: %s k des_file som_file predict.csv sdf_file"%argv[0]
        print "  k          : report top-1 to top-k results"
        print "  des_file   : descriptor, same as input for gap_predict"
        print "  som_file   : file of actual SOMs"
        print "               each line should be `name\\tatom1\\tatom2...`"
        print "  predict.csv: file generated by smartcyp"
        print "  sdf_file   : the one used to generate `predict.csv`"
        print "\nAttention"
        print "  1. reports are based on SOMs with only one atom"
        print "     - considering all types of SOMs"
        print "     - exclude SOM type `6`(O-conjugation)"
        print ""
        sys.exit(1)

    k = int(argv[1])

    mol_names = load_mol_names(argv[5])

    des = load_des(argv[2])   #key=name, value=[(atom,type),...]

    actual_all,actual_no6  = load_som(argv[3], des)      #key=name, value=[site1,site2,...]
    predict = load_predict(argv[4],des,mol_names)  #key=name, value=[(atom,rank,score),...]

    print "===report considering all SOMs except those with more than one atoms==="
    do_evaluate(actual_all,predict,k)
    print "\n===report exclude SOM type 6 (O-conjugation) and more than one atoms==="
    do_evaluate(actual_no6,predict,k)

def load_mol_names(infile):
    mol_names = []
    inf = open(infile,'r')
    line = inf.readline()
    while line != "":
        mol_names.append(line.strip())
        while line!="" and line.strip()!="$$$$":
            line = inf.readline()
        line = inf.readline()
    inf.close()
    return mol_names

def do_evaluate(actual,predict,k):
    results = []
    for i in xrange(1,k+1):
        total,miss,right = evaluate(actual,predict,i)
        error = total-miss-right
        results.append((i,right,error))
    print "totally %d samples, of which %d has no SOM labeled"%(total,miss)
    print "k  total miss right error accuracy"
    for k,right,error in results:
        print "%-2d %-5d %-5d %-g"%(k,right,error,1.*right/(right+error))
    print ""


def load_des(infile):
    des = {}
    inf = open(infile,'r')
    line = inf.readline()
    while line != "":
        name = line.split()[0].split("\\")[-1]
        name = name[:name.rfind(".")]
        des[name] = []
        line = inf.readline()
        while line!="" and line.startswith("\t"):
            temp = line.strip().split(",")[0]
            atom,type,val = temp.split(":")
            des[name].append((atom,type))
            line = inf.readline()
    inf.close()
    return des

def valid(actual,atom):
    for a,t in actual:
        if a==atom and t=='6':
            return False
    return True

def load_som(infile, des):
    actual_all = {}
    actual_no6 = {}
    inf = open(infile,'r')
    count = 0
    for line in inf:
        line = line.strip().split("\t")
        if not des.has_key(line[0]):
            count += 1
            continue
        actual_all[line[0]] = []
        actual_no6[line[0]] = []
        for atom in line[1:]:
            if "-" in atom:
                continue
            actual_all[line[0]].append(atom)
            if valid(des[line[0]],atom):
                actual_no6[line[0]].append(atom)
    inf.close()

    if count:
        print "totally %d samples of %s are not in `des`"%(count, infile)

    return actual_all,actual_no6


def load_predict(infile,des,mol_names):
    predict = {}
    inf = open(infile,'r')
    line = inf.readline()
    count = 0
    prev_name = ""
    for line in inf:
        line = line.strip().split(",")
        i = int(line[0])
        name = mol_names[i-1]
        if name!=prev_name and not des.has_key(name):
            count += 1
            prev_name = name
            continue
        if not predict.has_key(name):
            predict[name] = []
        #(atom,rank,score)
        predict[name].append((line[1].split(".")[-1],int(line[2]),line[3]))
        prev_name = name
    inf.close()

    for key,value in predict.iteritems():
        value.sort(key=lambda x:x[1])

    if count:
        print "totally %d samples of %s are not in `des_file`"%(count,infile)

    return predict

def evaluate(actual,predict,k):
    total = 0
    miss = 0
    right = 0

    for name in actual.iterkeys():
        total += 1
        if len(actual[name]) == 0:
            miss += 1
            continue
        found = False
        for item in predict[name][:k]:
            if item[0] in actual[name]:
                found = True
                break
        if found:
            right += 1

    return total,miss,right

main()


